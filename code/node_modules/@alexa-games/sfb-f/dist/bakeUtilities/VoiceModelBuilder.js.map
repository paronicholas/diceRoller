{"version":3,"file":"VoiceModelBuilder.js","sourceRoot":"","sources":["../../bakeUtilities/VoiceModelBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { VoiceModel } from \"./languageModel\";\nimport { StoryMetadataHelper } from './../importPlugins/storyMetadataHelper';\nimport { Instruction, InstructionType, SceneVariation } from './../story/storyMetadata';\nimport { LanguageModelBuilder, LanguageModelSlot, LanguageModelValue } from './languageModel';\nimport { Segmenter, SegmentType } from './../transformers/segmenter';\n\nexport interface IntentCategory {\n    id: string,\n    type: CategoryType,\n    utterances: string[],\n}\n\nexport enum CategoryType {\n    INTENT,\n    CUSTOM_SLOT,\n    AUTO_SLOT,\n    BUILT_IN_INTENT\n}\n\nconst SLOT_VERSION_BASE = 26;\n\nconst A_CHAR_CODE = 'a'.charCodeAt(0);\n\nconst SLOT_INTENT_NAME = 'CatchAllSlotIntent';\n\nconst INTENT_NUMBER_LIMIT: number = 220;\n\nconst OVERFLOW_INTENT_SLOT_NAME: string = \"OverflowIntentSlot\"\n\nexport interface ModelBuildParameter {\n    story: StoryMetadataHelper;\n    locale: string;\n    invocationName: string;\n    customSlots: {[key: string]: string[]|LanguageModelValue[]};\n    builtInIntents: {[key: string]: string[]};\n}\n\nexport interface ModelBuilder {\n    build(param: ModelBuildParameter): VoiceModel;\n}\n\nexport class AlexaVoiceModelBuilder implements ModelBuilder {\n    /**\n     * Given a imported story structure for SFB, automatically generate an Alexa Interaction Model.\n     */\n    public build(param: ModelBuildParameter): VoiceModel {\n        const storyAccessor = param.story;\n        \n        ModelBuilderHelper.autoIntentCount = 0;\n        ModelBuilderHelper.autoSlotCount = 0;\n\n        const builtInIntents = ModelBuilderHelper.buildBuiltInSampleToIntentMap(param.builtInIntents);\n        const categories = ModelBuilderHelper.categorizeByIntent(storyAccessor, builtInIntents);\n        const voiceModel = ModelBuilderHelper.buildVoiceModelFromCategory(categories, param.invocationName, param.customSlots, param.builtInIntents);\n\n        return voiceModel;\n    }\n}\n\nexport class ModelBuilderHelper {\n    static autoSlotCount: number = 0;\n    static autoIntentCount: number = 0;\n\n    static buildBuiltInSampleToIntentMap(intentToSamples: {[key: string]: string[];}): {[key: string]: string} {\n        const sampleToBuiltIn: {[key: string]: string} = {};\n        for (let intentName in intentToSamples) {\n            intentToSamples[intentName].forEach((sample) => {\n                sampleToBuiltIn[sample.toLowerCase()] = intentName;\n            });\n        }\n\n        return sampleToBuiltIn;\n    }\n\n    static isBuiltInIntent(intent: string) {\n        return intent.startsWith(\"AMAZON.\");\n    }\n\n    static isWildCardUtterance(utterance: string) {\n        return utterance === \"*\";\n    }\n\n    /**\n     * Given a SFB story metadata divide utterances based on the intent of the utterance.\n     */\n    static categorizeByIntent(story: StoryMetadataHelper, builtInIntents: {[key: string]: string}): IntentCategory[] {\n        let result: IntentCategory[] = [];\n\n        const utteranceToCategory: {[key: string]: IntentCategory} = {};\n\n        story.getAllScenes().forEach((scene) => {\n\n            scene.contents.forEach((content) => {\n                const categories = ModelBuilderHelper.getCategoriesFromScene(utteranceToCategory, builtInIntents, content);\n\n                result = result.concat(categories);\n            });\n        });\n\n        ModelBuilderHelper.registerCategoryToStory(story, utteranceToCategory);\n\n        return result;\n    }\n\n    /**\n     * Given the category list, construct a voice model object.\n     */\n    static buildVoiceModelFromCategory(categories: IntentCategory[], invocationName: string, customSlots: {[key: string]: (string|LanguageModelValue)[]}, builtInIntents: {[key:string]: string[]}): VoiceModel {\n        const modelBuilder = new LanguageModelBuilder(invocationName);\n\n        for (let item of categories) {\n            if (item.utterances.length === 0) {\n                continue;\n            }\n\n            if (item.type === CategoryType.INTENT) {\n                modelBuilder.addIntent({\n                    name: item.id,\n                    samples: item.utterances\n                });\n            } else if (item.type === CategoryType.AUTO_SLOT) {\n                const generatedSlotName = item.id;\n                const generatedSlotTypeName = `${generatedSlotName}Type`;\n                const utterances = ModelBuilderHelper.convertSlotUtteranceForModel(item.utterances);\n\n                modelBuilder.addSlotValues(generatedSlotTypeName, utterances);\n                modelBuilder.addSlotSamplesToIntent(SLOT_INTENT_NAME, [`{${generatedSlotName}}`], [{\n                    name: generatedSlotName,\n                    type: generatedSlotTypeName\n                }]);\n            } else if (item.type === CategoryType.CUSTOM_SLOT) {\n                const slots = ModelBuilderHelper.getSlotsFromUtterances(item.utterances);\n                const utterances = ModelBuilderHelper.convertSlotUtteranceForModel(item.utterances);\n\n                slots.forEach((slot) => {\n                    const customSlotTypeName = slot.type;\n                    const customSlotValues = customSlots[customSlotTypeName] || [];\n\n\n                    if (!ModelBuilderHelper.isBuiltInIntent(customSlotTypeName)) {\n                        modelBuilder.addSlotValues(customSlotTypeName, customSlotValues);\n                    }\n                });\n                modelBuilder.addSlotSamplesToIntent(SLOT_INTENT_NAME, utterances, slots);\n            }\n        }\n\n        for (let intentName of Object.keys(builtInIntents)) {\n            modelBuilder.addIntent({\n                name: intentName\n            });\n        }\n\n        return modelBuilder.build();\n    }\n\n    static getCategoriesFromScene(utteranceToCategory: {[key:string]: IntentCategory}, builtInIntents: {[key: string]: string}, sceneContent: SceneVariation): IntentCategory[] {\n        const instructions = sceneContent.sceneDirections;\n\n        if (!instructions) {\n            return [];\n        }\n\n        const registeredSlots = ModelBuilderHelper.buildSlotMap(instructions);\n        const sceneCategory: IntentCategory[] = [];\n\n        let instructionsQueue = JSON.parse(JSON.stringify(instructions));\n\n        const usedIntent: {[key: string]: boolean} = {};\n\n        while (instructionsQueue.length > 0) {\n            const checking = instructionsQueue.splice(0, 1)[0];\n            \n            if (checking.directionType === InstructionType.CHOICE) {\n                const utterances = (<string[]>checking.parameters.utterances);\n\n                const choiceCategories = ModelBuilderHelper.buildCategoriesForChoice(utterances, usedIntent, registeredSlots, builtInIntents, utteranceToCategory);\n                \n                choiceCategories.forEach((item) => sceneCategory.push(item));\n            } else if (checking.directionType === InstructionType.CONDITION) {\n                if (checking.parameters.directions && checking.parameters.directions.length > 0) {\n                    instructionsQueue = instructionsQueue.concat(checking.parameters.directions);\n                }\n            }\n        }\n\n        return sceneCategory;\n    }\n\n    static buildCategoriesForChoice(utterances: string[], usedIntent: {[key: string]: boolean}, slotNameToType: {[key:string]: string}, builtInIntentMap: {[key: string]: string}, utteranceToCategory: {[key:string]: IntentCategory}): IntentCategory[] {\n        const utteranceTypingResult = ModelBuilderHelper.splitUtteranceType(utterances, builtInIntentMap, slotNameToType);\n\n        utteranceTypingResult.autoIntents.forEach((utterance) => {\n            const categoryForUtterance = utteranceToCategory[utterance];\n            if (categoryForUtterance) {\n                const intentID = categoryForUtterance.id;\n                if (usedIntent[intentID]) {\n                    // remove utterance from the existing category for re-assignment\n                    const i = utteranceToCategory[utterance].utterances.indexOf(utterance);\n                    utteranceToCategory[utterance].utterances.splice(i, 1);\n                    delete utteranceToCategory[utterance];\n                }\n            }            \n        });\n\n        const choiceCategories = ModelBuilderHelper.buildCategoriesFromUtteranceTyping (\n            utteranceTypingResult.builtInIntents,\n            utteranceTypingResult.autoIntents,\n            utteranceTypingResult.autoSlots,\n            utteranceTypingResult.customSlots,\n            builtInIntentMap,\n            utteranceToCategory\n        );\n\n        choiceCategories.filter((category) => {\n            return category.type === CategoryType.INTENT;\n        }).forEach((category) => {\n            usedIntent[category.id] = true\n        })\n\n        return choiceCategories\n    }\n\n    static buildCategoriesFromUtteranceTyping(builtIns: string[], autoIntents: string[], autoSlots: string[], customSlots: string[], builtInIntentMap: {[key: string]: string}, utteranceToCategory: {[key:string]: IntentCategory}): IntentCategory[] {\n        const categories: IntentCategory[] = [];\n\n        if (builtIns.length > 0) {\n            builtIns.forEach((utterance) => {\n                const intentName = builtInIntentMap[utterance];\n                const category = {\n                    id: intentName,\n                    type: CategoryType.BUILT_IN_INTENT,\n                    utterances: []\n                }\n\n                utteranceToCategory[utterance] = category;\n                categories.push(category);\n            });\n        }\n\n        if (autoSlots.length > 0) {\n            categories.push({\n                id: OVERFLOW_INTENT_SLOT_NAME,\n                type: CategoryType.AUTO_SLOT,\n                utterances: autoSlots\n            });\n\n            ModelBuilderHelper.autoSlotCount ++;\n        }\n\n        if (customSlots.length > 0) {\n            categories.push({\n                id: 'custom',\n                type: CategoryType.CUSTOM_SLOT,\n                utterances: customSlots\n            });\n        }\n\n        if (autoIntents.length > 0) {\n            let categoryInUse: IntentCategory[] = [];\n            autoIntents.forEach((utterance) => {\n                const recentCategory = categoryInUse.length > 0? categoryInUse[categoryInUse.length - 1]: undefined;\n\n                if (utteranceToCategory[utterance] && (!recentCategory || utteranceToCategory[utterance].id !== recentCategory.id)) {\n                    categoryInUse.push(utteranceToCategory[utterance]);\n                } else if (!recentCategory) {\n                    const intentName = `flex${ModelBuilderHelper.numberToAlphabetCounting(ModelBuilderHelper.autoIntentCount)}Intent`;\n\n                    const generatedCategory: IntentCategory = {\n                        id: intentName,\n                        type: CategoryType.INTENT,\n                        utterances: [utterance]\n                    };\n\n                    if (ModelBuilderHelper.autoIntentCount > INTENT_NUMBER_LIMIT) {\n                        generatedCategory.id = OVERFLOW_INTENT_SLOT_NAME;\n                        generatedCategory.type = CategoryType.AUTO_SLOT;\n                    }\n\n                    categoryInUse.push(generatedCategory);\n                    utteranceToCategory[utterance] = generatedCategory;\n                    ModelBuilderHelper.autoIntentCount ++;\n                } else if (!utteranceToCategory[utterance]) {\n                    utteranceToCategory[utterance] = recentCategory;\n                    recentCategory.utterances.push(utterance);    \n                }\n            });\n            categoryInUse.forEach((cat) => categories.push(cat));\n        }\n\n        return categories;\n    }\n\n    /**\n     * Split a list of utterances in by their utterance type.\n     * Three utterances types are:\n     * 1. Auto Intent\n     * 2. Built In Intents\n     * 3. Auto Slot\n     * 4. Custom Slot\n     */\n    static splitUtteranceType(utterances: string[], builtInIntents: {[key: string]: string}, registeredSlots:  {[key: string]: string}): {\n        autoIntents: string[],\n        builtInIntents: string[],\n        autoSlots: string[],\n        customSlots: string[]\n    } {\n        const autoSlotUtterances: string[] = [];\n        const customSlotUtterances: string[] = [];\n        const intentUtterances: string[] = [];\n        const builtInUtterances: string[] = [];\n\n        for (let utterance of utterances) {\n            const segmenter = new Segmenter([{\n                brackets: \"{}\",\n                preserve: false,\n                type: SegmentType.Element\n            }]);\n            \n            const segments = segmenter.parse(utterance);\n\n            const normalizedUtterance = segments.map((seg) => {\n                return seg.type === SegmentType.Element? seg.original: seg.value.toLowerCase();\n            }).reduce((prev, curr): string => {\n                if (prev) {\n                    return prev + curr;\n                } else {\n                    return curr;\n                }\n            });\n\n            if (ModelBuilderHelper.isWildCardUtterance(normalizedUtterance)) {\n                continue;\n            } else if (ModelBuilderHelper.isBuiltInIntent(normalizedUtterance)) {\n                continue;\n            } else if (builtInIntents[normalizedUtterance]) {\n                builtInUtterances.push(normalizedUtterance);\n            } else if (ModelBuilderHelper.hasUserDefinedSlots(normalizedUtterance)) {\n                const slotStandardUtterance = ModelBuilderHelper.standarizeSlottedUtterance(normalizedUtterance, registeredSlots);\n\n                customSlotUtterances.push(slotStandardUtterance);\n            } else if (ModelBuilderHelper.hasNumerics(normalizedUtterance)) {\n                autoSlotUtterances.push(normalizedUtterance);\n            } else {\n                intentUtterances.push(normalizedUtterance);\n            }\n        }\n\n        return {\n            autoIntents: intentUtterances,\n            builtInIntents: builtInUtterances,\n            autoSlots: autoSlotUtterances,\n            customSlots: customSlotUtterances\n        }\n    }\n\n    /**\n     * Build a map of { slot name : slot type } registered within the given list of scene instructions.\n     */\n    static buildSlotMap(instructions: Instruction[]): {[key: string]: string} {\n        const registeredSlots: {[key:string]: string} = {};\n\n        let instructionsQueue = JSON.parse(JSON.stringify(instructions));\n\n        while (instructionsQueue.length > 0) {\n            const checking = instructionsQueue.splice(0, 1)[0];\n            \n            if (checking.directionType === InstructionType.SLOT) {\n                const name: string = checking.parameters.variableName;\n                const type: string = checking.parameters.variableType;\n\n                registeredSlots[name] = type;\n            } else if (checking.directionType === InstructionType.CONDITION) {\n                if (checking.parameters.directions && checking.parameters.directions.length > 0) {\n                    instructionsQueue = instructionsQueue.concat(checking.parameters.directions);\n                }\n            }\n        }\n\n        return registeredSlots;\n    }\n\n    static standarizeSlottedUtterance(utterance: string, slotMap: {[key: string]: string;}): string {\n        return utterance.replace(/{([\\s\\S]+?)(?:[ \\t]+?as[ \\t]+?([\\s\\S]+?))?}/g,\n            (match: any, slotName: string, slotType: string) => {\n                if (slotName && !slotType && slotMap[slotName]) {\n                    return `{${slotName} as ${slotMap[slotName]}}`;\n                } else if (slotName && !slotType && !slotMap[slotName]) {\n                    return `{${slotName} as ${slotName}}`;\n                } else {\n                    return match;\n                }\n            });\n    }\n\n    static hasUserDefinedSlots(utterance: string) {\n        return !!utterance.match(/{[\\s\\S]+?([ \\t]+?as[ \\t]+?[\\s\\S]+?)?}/g);\n    }\n\n    static hasNumerics(utterance: string) {\n        return !!utterance.match(/[\\d]+?/g);\n    }\n\n    static numberToAlphabetCounting(i: number) {\n        const base26Count = i.toString(SLOT_VERSION_BASE);\n    \n        const alphaBaseCount = base26Count.replace(/./g, (match): string => {\n            if (isNaN(parseInt(match, 10))) {\n                return String.fromCharCode(match.charCodeAt(0) + 10);\n            } else {\n                return String.fromCharCode(A_CHAR_CODE + parseInt(match, 10));\n            }\n        });\n    \n        return alphaBaseCount;\n    }\n\n    static getSlotsFromUtterances(utterances: string[]): LanguageModelSlot[] {\n        const slots: {[key:string]: LanguageModelSlot}= {};\n        utterances.forEach((item) => {\n            const segmenter = new Segmenter([{\n                brackets: \"{}\",\n                preserve: false,\n                type: SegmentType.Element\n            }]);\n            \n            const segments = segmenter.parse(item);\n\n            for (let segment of segments) {\n                const value = segment.value;\n\n                if (segment.type === SegmentType.Element) {\n                    const slotRegex = /^([\\s\\S]+?)[ \\t]+?as[ \\t]+?([\\s\\S]+?)$/; \n                    const match = slotRegex.exec(value);\n\n                    if (match === null) {\n                        throw new Error(`Unexpected slot format '${value}' in Utterance '${item}'`);\n                    }\n\n                    const type = match[2];\n                    const name = match[1];\n\n                    slots[name] = {\n                        name: name,\n                        type: type\n                    }\n                }\n            }\n        });\n\n        return Object.values(slots);\n    }\n\n    static convertSlotUtteranceForModel(utterances: string[]): string[] {\n        const flattenedUtterance = JSON.stringify(utterances);\n\n        const slotRegex = /{([\\s\\S]+?)[ \\t]+?as[ \\t]+?([\\s\\S]+?)}/g; \n\n        const correctedUtterances = flattenedUtterance.replace(slotRegex, (match, slotName, slotType): string => {\n            return `{${slotName}}`;\n        });\n\n        return <string[]>JSON.parse(correctedUtterances);\n    }\n\n    static registerCategoryToStory(story: StoryMetadataHelper, utteranceToCategory: {[key:string]: IntentCategory;}) {\n        const scenes = story.getAllScenes();\n        for (let scene of scenes) {\n            for (let content of scene.contents) {\n                if (!content.sceneDirections) {\n                    continue;\n                }\n    \n                ModelBuilderHelper.registerCategoryToInstructions(content.sceneDirections, utteranceToCategory);\n            }\n        }\n        story.setAllScenes(scenes);\n    }\n\n    static registerCategoryToInstruction(instruction: Instruction, utteranceToCategory: {[key:string]: IntentCategory;}) {\n        if (instruction.parameters.utterances) {\n            const uniqueIntentsUsed: any = {};\n\n            for (let utterance of <string[]>instruction.parameters.utterances) {\n                const category = utteranceToCategory[utterance];\n\n                if (category) {\n                    uniqueIntentsUsed[category.id] = true;\n                }             \n            }\n\n            if (!instruction.parameters.utteranceIDs) {\n                instruction.parameters.utteranceIDs = [];\n            }\n            \n            instruction.parameters.utteranceIDs = instruction.parameters.utteranceIDs.concat(Object.keys(uniqueIntentsUsed));\n        }\n    }\n\n    static registerCategoryToInstructions(instructions: Instruction[], utteranceToCategory: {[key:string]: IntentCategory;}) {\n        for (let instruction of instructions) {\n            if (instruction.directionType === InstructionType.CHOICE) {\n                ModelBuilderHelper.registerCategoryToInstruction(instruction, utteranceToCategory);\n            } else if (instruction.directionType === InstructionType.CONDITION) {\n                if (instruction.parameters.directions && instruction.parameters.directions.length > 0) {\n                    ModelBuilderHelper.registerCategoryToInstructions(instruction.parameters.directions, utteranceToCategory);\n                }\n            }\n        }\n    }\n}"]}