{"version":3,"file":"storyFeatureFinder.js","sourceRoot":"","sources":["../../importPlugins/storyFeatureFinder.ts"],"names":[],"mappings":"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","sourcesContent":["import { \n    StoryBlockFinder, \n    EndType, \n    BlockStartExpressions\n} from './storyBlockFinder';\nimport { StoryBlockRange } from './storyBlockRange';\nimport { StoryBlock, SceneStoryBlock } from './storyBlock';\n\nexport class StoryFeatureFinder {\n    // Looks for -> scene or <-> scene style references on a line\n    private static readonly ReferenceNotationMatch = /^\\s*<?->\\s+(.*)\\s*$/;\n\n    // Looks for { } or spaces on a line. Other characters result in no-match\n    private static readonly BracesOrSpaces = /^[\\s\\{\\}]*$/;\n\n\n    constructor(private lines: string[]) {\n    }\n\n    /**\n     * Finds the range of the given scene. Returns undefined if the scene is not present.\n     * @param sceneId ID of the scene to find.\n     */\n    public findScene(sceneId: string): SceneStoryBlock | undefined {\n        sceneId = sceneId.trim();\n\n        const sceneFinder = new StoryBlockFinder({\n            blockEndType: EndType.NextBlock,\n            blockName: sceneId,\n            lines: this.lines,\n            blockStartMatch: BlockStartExpressions.SceneMatch\n        });\n        \n        const result = sceneFinder.getNextBlock();\n        if (result) {\n            return new SceneStoryBlock(result.lines, result.blockName, result.range);\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Returns Ranges containing references to the specified scene. \n     * @param sceneId Scene ID to find references to.\n     */\n    public getReferences(sceneId: string): StoryBlockRange[] {\n        sceneId = sceneId.trim();\n\n        const result: StoryBlockRange[] = [];\n\n        const sceneFinder = new StoryBlockFinder({\n            blockEndType: EndType.NextBlock,\n            lines: this.lines,\n            blockStartMatch: BlockStartExpressions.SceneMatch\n        });\n\n        let sceneBlock = sceneFinder.getNextBlock();\n        while (sceneBlock) {\n            const thenFinder = new StoryBlockFinder({\n                blockEndType: EndType.NextBlock,\n                blockName: 'then',\n                lines: this.lines,\n                range: sceneBlock.range,\n                blockStartMatch: BlockStartExpressions.ScenePropMatch            \n            });\n    \n            let thenBlock = thenFinder.getNextBlock();\n            while (thenBlock) {\n                const refFinder = new StoryBlockFinder({\n                    blockEndType: EndType.OneLine,\n                    range: thenBlock.range,\n                    lines: this.lines,\n                    blockStartMatch: StoryFeatureFinder.ReferenceNotationMatch,\n                    blockName: sceneId            \n                });\n\n                let reference = refFinder.getNextBlock();\n                while (reference) {\n                    result.push(reference.range);\n                    reference = refFinder.getNextBlock();\n                }\n\n                if (result.length > 0) {\n                    this.expandToSimpleHearBlocks(result, thenBlock.range);\n                }\n    \n                thenBlock = thenFinder.getNextBlock();\n            }\n\n            sceneBlock = sceneFinder.getNextBlock();\n        }\n\n        return result;\n    }\n\n    /**\n     * Return range of the given property type or undefined if it is not found.\n     * @param sceneBlock Range to include in the quest for the scene property.\n     * @param propertyType Values like 'say', 'then', etc.\n     */\n    public getScenePropertyByType(sceneBlock: StoryBlockRange, propertyType: string): StoryBlock | undefined {\n        const blockFinder = new StoryBlockFinder({\n            blockEndType: EndType.NextBlock,\n            blockName: propertyType,\n            lines: this.lines,\n            range: sceneBlock,\n            blockStartMatch: BlockStartExpressions.ScenePropMatch            \n        });\n\n        return blockFinder.getNextBlock();\n    }\n\n    /**\n     * Find simple hear blocks (blocks with nothing else but a single reference) and replaces the reference to the\n     * entire hear block.\n     * @param result List of references to expand\n     * @param thenBlock Range to scan\n     */\n    private expandToSimpleHearBlocks(result: StoryBlockRange[], thenBlock: StoryBlockRange): void {\n        \n        const hearFinder = new StoryBlockFinder({\n            blockEndType: EndType.BraceMatch,\n            range: thenBlock,\n            lines: this.lines,\n            blockStartMatch: BlockStartExpressions.HearMatch            \n        });\n\n        let index = 0;\n\n        let hearBlock = hearFinder.getNextBlock();\n        while (index < result.length && hearBlock) {\n            while (index < result.length &&\n                result[index].end.row < hearBlock.range.start.row) {\n                // Skip past results that precede the current hear block.\n                index++;\n            }\n\n            if (index < result.length && \n                result[index].intersectsWith(hearBlock.range)) {\n                // Is hear block simple? use it!\n                if (this.isBlockSimple(hearBlock.range, result[index])) {\n                    result[index] = hearBlock.range;\n                }\n                index++;\n            }\n\n            hearBlock = hearFinder.getNextBlock();\n        }\n    }\n\n    // A simple block has only spaces or braces on lines that are outside of the ignore range.\n    // The first line may have any characters.  For example:\n    //     hear foo \n    //     {\n    //         -> test (ignored)\n    //\n    //     }\n    private isBlockSimple(block: StoryBlockRange, ignore: StoryBlockRange): boolean {\n        for (let i = block.start.row + 1; i <= block.end.row; i++) {\n            let line = block.cropToRange(this.lines[i], i);\n\n            if (i === ignore.start.row && i < ignore.end.row) {\n                continue;\n            }\n\n            if (!StoryFeatureFinder.BracesOrSpaces.test(line)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}"]}